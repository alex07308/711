## Создать таблицы и задать связи, заполнить данными для следующих примеров:

### 1. Конференции и выступления:
- конференция может иметь несколько выступлений
- выступление может принадлежать только одной конференции
- конференция - название, дата, адрес
- выступление - название, дата, тема

### 2. Поставщики и транспортные средства:
 - поставщик может иметь несколько транспортных средств
 - транспортное средство может принадлежать только одному поставщику
 - поставщик - название, телефон
 - транспортное средство - марка, модель, грузоподъемность

### 3. Книги и отзывы:
- книга может иметь несколько отзывов
- отзыв может принадлежать только одной книге
- книга - название, жанр, год издания
- отзыв - текст, оценка

## Для каждого примера сделать вывод связанных сущностей (за один запрос)
- зависимая сущность должна быть представлена в виде массива объектов
- учесть случай когда на главную таблицу может не быть ссылок в строках зависимой таблицы
- если на строки из главной таблицы нет ссылок из зависимой таблицы, эти строки всё равно должны выводиться
- на одну из строк главной таблицы должно быть хотя бы 2 ссылки из зависимой таблицы

- /*1. Конференции и выступления:
конференция может иметь несколько выступлений
выступление может принадлежать только одной конференции
конференция - название, дата, адрес
выступление - название, дата, тема*/

drop table if exists conference, presentation cascade;

create table conference
(
	id int primary key,
	name text,
	conf_date date,
	address text
);

create table presentation
(
	id int primary key,
	conf_id int references conference,
	name text,
	pres_date date,
	theme text
);

insert into conference (id, name, conf_date, address)
values
(1, 'conference 1', '2024.03.01', 'address 1'),
(2, 'conference 2', '2024.03.02', 'address 2'),
(3, 'conference 3', '2024.03.03', 'address 3');


insert into presentation (id, conf_id, name, pres_date, theme)
values
(1, 1, 'name 1', '2024.03.05', 'theme 1'),
(2, 1, 'name 2 ', '2024.03.07', 'theme 2'),
(3, 2, 'name 3 ', '2024.03.09', 'theme 3');

select
	c.id,
	c.name,
	c.conf_date,
	c.address,
	coalesce(jsonb_agg(json_build_object(
		'id', p.id, 'name', p.name, 'pres_date', p.pres_date, 'theme', p.theme))
			filter (where p.id is not null), '[]') as presentation
from conference c
left join presentation p on c.id = p.conf_id
group by c.id
order by c.id;




/*2. Поставщики и транспортные средства:
поставщик может иметь несколько транспортных средств
транспортное средство может принадлежать только одному поставщику
поставщик - название, телефон
транспортное средство - марка, модель, грузоподъемность*/

drop table if exists provider, vehicle cascade;

create table provider
(
	id int primary key,
	name text,
	tel_number text
);

create table vehicle
(
	id int primary key,
	prov_id int references provider,
	name text,
	model text,
	cargo int
);

insert into provider (id, name, tel_number)
values
(1, 'name 1', '89881845957'),
(2, 'name 2', '89186498364'),
(3, 'name 3', '89189825712');


insert into vehicle (id, prov_id, name, model, cargo)
values
(1, 1, 'name01', 'model 1', 250),
(2, 1, 'name02', 'model 2', 500),
(3, 2, 'name03', 'model 3', 1000);



select
	provider.id,
	provider.name,
	provider.tel_number,
	coalesce(jsonb_agg(json_build_object(
		'id', vehicle.id, 'name', vehicle.name, 'model', vehicle.model, 'cargo', vehicle.cargo))
			filter (where v.id is not null), '[]') as vehicle
from provider 
left join vehicle on provider.id = vehicle.prov_id
group provider.id
order by provider.id;




/*3. Книги и отзывы:
книга может иметь несколько отзывов
отзыв может принадлежать только одной книге
книга - название, жанр, год издания
отзыв - текст, оценка*/

drop table if exists book, review cascade;

create table book
(
	id int primary key,
	name text,
	genre text,
	publication_year date
);

create table review
(
	id int primary key,
	book_id int references book,
	review_text text,
	rate int
);

insert into book (id, name, genre, publication_year)
values
(1, 'book 1', '2024.03.01', 'address 1'),
(2, 'book 2', '2024.03.02', 'address 2'),
(3, 'book 3', '2024.03.03', 'address 3');


insert into review (id, book_id, review_text, rate)
values
(1, 1, 'text 1', 5),
(2, 1, 'text 2', 4),
(3, 2, 'text 3', 3);

select
	b.id,
	b.name,
	b.genre,
	b.publication_year,
	coalesce(jsonb_agg(json_build_object(
		'id', r.id, 'review_text', r.review_text, 'rate', r.rate))
			filter (where r.id is not null), '[]') as review
from book b
left join review r on b.id = r.book_id
group by b.id
order by b.id;



